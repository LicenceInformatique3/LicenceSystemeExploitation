#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "process.h"
#include "cpu.h"

WORD mem[128];     /* memoire                       */
static int clock = 0;
/**********************************************************
** Placer une instruction en memoire
***********************************************************/

void make_inst(int adr, unsigned code, unsigned i, unsigned j, short arg) {
	union { WORD word; INST fields; } inst;
	inst.fields.OP  = code;
	inst.fields.i   = i;
	inst.fields.j   = j;
	inst.fields.ARG = arg;
	mem[adr] = inst.word;
}

/**********************************************************
** Simulation de la CPU (mode utilisateur)
***********************************************************/

/* instruction d'addition */
PSW cpu_ADD(PSW m) {
	m.AC = m.DR[m.RI.i] += (m.DR[m.RI.j] + m.RI.ARG);
	m.PC += 1;
	printf("ADD : %d\n",m.AC);
	return m;
}

/* instruction de soustraction */
PSW cpu_SUB(PSW m) {
	m.AC = m.DR[m.RI.i] -= (m.DR[m.RI.j] + m.RI.ARG);
	m.PC += 1;
	printf("SUB : %d \n",m.AC);
	return m;
}

/* instruction de comparaison */
PSW cpu_CMP(PSW m) {
	m.AC = (m.DR[m.RI.i] - (m.DR[m.RI.j] + m.RI.ARG));
	m.PC += 1;
	printf("CMP\n");
	return m;
}

/* instruction de IF Greater Than*/
PSW cpu_IFGT(PSW m){
	if(m.AC > 0){
		m.PC = (m.DR[m.RI.i] + (m.RI.ARG)-1);
	}
	m.PC += 1;
	printf("IFGT\n");
	return m;
}

/* instruction de "no operation"*/
PSW cpu_NOP(PSW m){
	m.PC += 1;
	printf("NOP\n");
	return m;
}

/* instruction de Jump */
PSW cpu_JUMP(PSW m){
	m.PC = (m.DR[m.RI.i] + m.RI.ARG);
	printf("JUMP\n");
	return m;
}

/* instruction d'exit */
PSW cpu_HALT(PSW m){
	printf("HALT\n");
	processes[current_process].state = EMPTY;
	nextProcess();
	memcpy(&m, &processes[current_process].cpu, sizeof (PSW));
	return m;
}

/* instruction syst√®me */
PSW cpu_SYSC(PSW m){
	m.IN = INT_SYSC;
	printf("INT_SYSC\n");
	return m;
}

/* instruction LOAD */
PSW cpu_LOAD(PSW m){
	m.AC = ((m.DR[m.RI.j] + m.RI.ARG));
	if((m.AC < 0) || (m.AC >= m.SS)){
		m.IN = INT_SEGV;
		return m;
	}
 	m.AC = mem[m.AC];	
 	m.DR[m.RI.i] = m.AC;
	m.PC += 1;
	return m;
}

/* instruction clock */
void cpu_clock(PSW * m){
	if(++clock == 3){
		clock = 0;
		m->IN = INT_CLOCK;
	}else{
		m->IN = INT_NONE;
	}
}

/* instruction store */
PSW cpu_STORE(PSW m){
	m.AC = ((m.DR[m.RI.j] + m.RI.ARG));
	if((m.AC < 0) || (m.AC >= m.SS)){
		m.IN = INT_SEGV;
		return m;
	}	
	mem[m.SB + m.AC] = m.DR[m.RI.i];	
 	m.AC = m.DR[m.RI.i];
	m.PC += 1;
	return m;
}

/* Simulation de la CPU */
PSW cpu(PSW m) {
	union { WORD word; INST in; } inst;
	
	/*** lecture et decodage de l'instruction ***/
	if (m.PC < 0 || m.PC >= m.SS) {
		m.IN = INT_SEGV;
		return (m);
	}
	inst.word = mem[m.PC + m.SB];
	m.RI = inst.in;
	/*** execution de l'instruction ***/
	switch (m.RI.OP) {
	case INST_ADD:
		m = cpu_ADD(m);
		break;
	case INST_SUB:
		m = cpu_SUB(m);
		break;
	case INST_CMP:
		m = cpu_CMP(m);
		break;
	case INST_IFGT:
		m = cpu_IFGT(m);
		break;
	case INST_NOP:
		m = cpu_NOP(m);
		break;
	case INST_JUMP:
		m = cpu_JUMP(m);
		break;
	case INST_HALT:
		m = cpu_HALT(m);
		break;
	case INST_SYSC:
		m = cpu_SYSC(m);
		break;
	case INST_LOAD:
		m = cpu_LOAD(m);
		break;
	case INST_STORE:
		m = cpu_STORE(m);
		break;
	default:
		/*** interruption instruction inconnue ***/
		m.IN = INT_INST;
		return (m);
	}

	/*** interruption apres chaque instruction ***/
	//m.IN = INT_TRACE;
	cpu_clock(&m);
	return m;
}
