#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <time.h>
#include "cpu.h"
#include "process.h"
#include "systemIO.h"
#include "system.h"

int lastInputTime = 0;

/**********************************************************
** Demarrage du systeme
***********************************************************/

PSW systeme_init(void) {
	PSW cpu;
	//PSW cpu2;
	process_init();
	printf("Booting.\n");
	/*** creation d'un programme ***/
	/*
	make_inst(0, INST_SUB, 0, 0, 0); 		// R1 -= R1-0
	make_inst(1, INST_SUB, 1, 1, -1000); 	// R2 = R2-(-1000)
	make_inst(2, INST_SUB, 2, 2, -10);   	// R3 = R3-(-10)
	make_inst(3, INST_SUB, 3, 3, 0);   		// R4 = R4+500
	make_inst(4, INST_CMP, 0, 1, 0);
	make_inst(5, INST_IFGT, 3, 0,11);
	make_inst(6, INST_NOP, 0, 0, 0);
	make_inst(7, INST_NOP, 0, 0, 0);
	make_inst(8, INST_NOP, 0, 0, 0);
	make_inst(9, INST_ADD, 0, 2, 0);   // R1 += R3
	make_inst(10, INST_JUMP, 3, 0, 4);
	make_inst(11, INST_HALT, 0, 0, 0);
	*/
	
	/*** Appels Système test ***/
	//Test SYSC_NEW_THREAD
	/*
	make_inst(0, INST_SUB, 0, 0, 0);
	make_inst(1, INST_SYSC, 1, 1, SYSC_NEW_THREAD);
	make_inst(2, INST_IFGT, 0, 0, 10);
	make_inst(3, INST_SYSC, 0, 0, SYSC_PUTI);
	make_inst(4, INST_SYSC, 0, 0, SYSC_EXIT);
	make_inst(10, INST_SUB, 0, 0, -1000);
	make_inst(11, INST_SYSC, 0, 0, SYSC_PUTI);
	make_inst(12, INST_SYSC, 0, 0, SYSC_EXIT);
	*/
	
	
	/*SLEEP
    make_inst(0, INST_SUB, 0, 0, 0);
    make_inst(1, INST_SYSC, 1, 1, SYSC_NEW_THREAD);
    make_inst(2, INST_IFGT, 0, 0, 10);
    make_inst(3, INST_SYSC, 0, 0, SYSC_PUTI);
    make_inst(4, INST_SYSC, 0, 0, SYSC_EXIT);
    make_inst(10, INST_SUB, 1, 1, -3);
    make_inst(11, INST_SYSC, 1, 0, SYSC_SLEEP);
    make_inst(12, INST_SYSC, 0, 0, SYSC_PUTI);
    make_inst(13, INST_ADD, 0, 2, 1);
    make_inst(14, INST_JUMP, 2, 2, 11);
	*/
	
	//Test GETCHAR
    make_inst(0, INST_SUB, 0, 0, 0);
    make_inst(1, INST_SYSC, 1, 1, SYSC_NEW_THREAD);
    make_inst(2, INST_IFGT, 0, 0, 10);
    make_inst(3, INST_SUB, 1, 1, -4);
    make_inst(4, INST_SYSC, 1, 0, SYSC_SLEEP);
    make_inst(5, INST_SYSC, 2, 0, SYSC_GETCHAR);
    make_inst(6, INST_SYSC, 2, 0, SYSC_PUTI);
    //make_inst(7, INST_JUMP, 3, 3, 4);
    make_inst(10, INST_SYSC, 0, 0, SYSC_EXIT);

	/*** valeur initiale du PSW ***/
	memset (&cpu, 0, sizeof(cpu));
	cpu.PC = 0;
	cpu.SB = 0;
	cpu.SS = 20;
	setProcessReady(0,cpu);
	
	/*** Deuxième processus ***/
	/*
	memset (&cpu2, 0, sizeof(cpu2));
	cpu2.PC = 0;
	cpu2.SB = 0;
	cpu2.SS = 20;
	setProcessReady(1,cpu2);
	*/
	return cpu;
}

char * getStrFromIntSysc(int int_sysc){
	switch (int_sysc) {
		case SYSC_EXIT:
			return "SYSC_EXIT";
		case SYSC_PUTI:
			return "SYSC_PUTI";
		case SYSC_NEW_THREAD:
			return "SYSC_NEW_THREAD";
		case SYSC_SLEEP:
			return "SYSC_SLEEP";
		case SYSC_GETCHAR:
			return "SYSC_GETCHAR";
		case SYSC_FORK:
			return "SYSC_FORK";
		default:
			return "UNKNOW";
	}
}

void trace_Display(PSW * m){
	switch (m->IN) {
		case INT_SEGV:
			printf("Address Error : INT_SEGV \n Interupt Number %d\n",m->IN);
			break;
		case INT_TRACE:
			printf("Trace Interupt : INT_TRACE \n Interupt Number %d\n",m->IN);
			break;
		case INT_INST:
			printf("Instruction Unknown : INT_INST \n Interupt Number %d\n",m->IN);
			break;
		case INT_SYSC:
			printf("Instruction Système: INT_SYSC \n Interupt Number %s\n",getStrFromIntSysc(m->RI.ARG));
			break;
	}
}
	
void systeme_trace(PSW * m) {
	trace_Display(m);
	printf("Program Counter : %d\n",m->PC);
	for(int i = 0; i < 8;i++){
		printf("Data Registers N°%d : %d\n",i,m->DR[i]);
	}
	printf("Process Num : %d\n",current_process);
}

void systeme_sysc_exit(PSW * m){
	trace_Display(m);
	processes[current_process].state = EMPTY;
	nextProcess();
	memcpy(m, &processes[current_process].cpu, sizeof (PSW));
}

void systeme_sysc_puti(PSW * m){
	printf("OUTPUT : %d\n", m->DR[m->RI.i]);
	++m->PC;
}

void systeme_sysc(PSW * m){
	switch (m->RI.ARG) {
		case SYSC_EXIT:
			systeme_sysc_exit(m);
			break;
		case SYSC_PUTI:
			systeme_sysc_puti(m);
			break;
		case SYSC_NEW_THREAD:
			system_sysc_thread(m);
			break;
		case SYSC_SLEEP:
			system_sysc_sleep(m);
			break;
		case SYSC_GETCHAR:
			system_sysc_getchar(m);
			break;
		case SYSC_FORK:
			system_sysc_fork(m);
			break;
	}
	systeme_trace(m);
} 

void systeme_exit(PSW * m){	
	systeme_trace(m);
	exit(-1);
}

void systeme_clock(PSW * m){
	printf("%d eme instr : \n", m->PC);
	processes[current_process].cpu = *m;
	//memcpy(&processes[current_process].cpu, m, sizeof (PSW));
	nextProcess();
	memcpy(m, &processes[current_process].cpu, sizeof (PSW));
	systeme_trace(m);
}

void system_sysc_thread(PSW* m) {
    Process* child = process_alloc();
    
    memcpy(&child->cpu, m, sizeof (PSW));
	
    m->AC = child->number;
    m->DR[m->RI.i] = child->number;
    m->PC += 1;

    child->cpu.AC = 0;
    child->cpu.DR[m->RI.i] = 0;
	child->cpu.PC += 1;

    child->state = READY;
    systeme_trace(m);
}

void system_sysc_sleep(PSW* m){
	processes[current_process].state = SLEEP;
	processes[current_process].waketime = time(NULL) + m->DR[m->RI.i];
	++m->PC;
	systeme_clock(m); //on change de processus
}

void system_sysc_getchar(PSW *m){
	printf("hello there\n");
	Process* proc = &processes[current_process];
	char c = system_io_getChar(proc);
	printf("char : %c\n",c);
    systeme_trace(m);
    //Change de processus (en attente de caractère)
    if(proc->state == GETCHAR){
        systeme_clock(m);
        return;
    }   
    m->DR[m->RI.i] = c;
    ++m->PC;
}

void system_sysc_fork(PSW * m){
	
}

/**********************************************************
** Simulation du systeme (mode systeme)
***********************************************************/

PSW systeme(PSW m) {
	if(lastInputTime + 3 < time(NULL)){
		system_io_fake_input();
		lastInputTime = time(NULL);
	}

	switch (m.IN) {
		case INT_INIT:
			return (systeme_init());
		case INT_SEGV:
			systeme_exit(&m);
			break;
		case INT_TRACE:
			 systeme_trace(&m);
			 break;
		case INT_INST:
			systeme_exit(&m);
			break;
		case INT_CLOCK:
			systeme_clock(&m);
			break;
		case INT_SYSC:
			systeme_sysc(&m);
			break;
	}
	return m;
}
